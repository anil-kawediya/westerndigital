1: Basic Protocol Functionality as discussed:
	•	Tunnel vs Transport mode
	•	Multiple ESP cipher/auth combos (parametrized)
	•	SA negotiation checks and rekey mid-I/O
	•	Inbound vs outbound flow checks (write → read, verify)
	•	Anti-replay tests via packet loss / reorder (using tc netem)
	•	Uses fio for storage I/O and verifies checksums to detect corruption

Important pre-reqs and assumptions (read before running):
	•	Linux host, root privileges (script checks for root).
	•	The storage target (Western Digital drive) is mounted on the test host (e.g., /mnt/wd_target) or is accessible as a path where we can create/verify files. You must mount the device before running the test.
	•	fio, ip, tc (from iproute2), and openssl (for generating keys if needed) are installed.
	•	This script uses ip xfrm command to create IPsec SAs/policies. If you use strongSwan or vendor tooling to program SAs, adapt the helper functions.
	•	The script will modify kernel IPsec state and network qdisc — run it in a safe environment (lab or VM).
	•	You (the operator) are responsible for network/state cleanup when running on a shared machine (script attempts cleanup).



# ------------------------------------------
# IPSec Tunnel vs. Transport Mode Test
# ------------------------------------------

# Assumptions:
# - Test host connected to WD storage target over TCP/IP
# - IPsec can be configured via OS tools (e.g., strongSwan) or driver API
# - Storage I/O can be issued via fio or NVMe/iSCSI command library
# - Functions are wrappers around CLI or driver calls

# STEP 1: Test Environment Setup
def setup_environment():
    configure_network()                 # Configure IP addresses, routes
    verify_storage_target_online()       # Ping or health check storage endpoint

# STEP 2: Configure IPsec for a given mode
def configure_ipsec(mode):
    if mode == "tunnel":
        # Encapsulate entire IP packet
        setup_tunnel_mode(local_ip, remote_ip, encryption="aes-gcm", auth="sha256")
    elif mode == "transport":
        # Encrypt only payload, not headers
        setup_transport_mode(local_ip, remote_ip, encryption="aes-gcm", auth="sha256")
    else:
        raise ValueError("Unsupported mode")

    verify_sa_established()              # Check security association table
    log("IPSec configured in {} mode".format(mode))

# STEP 3: Run I/O Test Over IPsec
def run_storage_io(mode):
    log("Running storage I/O in {} mode".format(mode))
    start_time = now()

    # Example: Run fio with 4KB random read/write workload
    run_fio(target_ip=remote_ip, 
            block_size="4k",
            io_depth=32,
            num_jobs=4,
            rw_pattern="randrw",
            verify_data=True)            # Ensure post-read data matches written data

    duration = now() - start_time
    log("I/O completed in {} seconds for {} mode".format(duration, mode))

# STEP 4: Validate Data Integrity
def validate_data_integrity():
    # Compare pre- and post-write checksums
    checksum_before = compute_checksum(test_file)
    checksum_after = compute_checksum(read_back_from_drive())

    if checksum_before != checksum_after:
        raise TestFailure("Data corruption detected under IPsec")
    log("Data integrity OK")

# STEP 5: Cleanup
def cleanup_ipsec():
    teardown_ipsec()
    verify_no_sa_present()

# STEP 6: Main Test Runner
def test_tunnel_vs_transport():
    setup_environment()

    for mode in ["tunnel", "transport"]:
        configure_ipsec(mode)
        run_storage_io(mode)
        validate_data_integrity()
        cleanup_ipsec()

    log("Both Tunnel and Transport mode tests passed successfully")

# Run Test
test_tunnel_vs_transport()